#!/usr/bin/python3.6
import email
import sys
import os
from ffmpy import FFmpeg # pip install ffmpy
from google.cloud import speech # pip install google-cloud-speech
from subprocess import PIPE
import base64
import random
import datetime


def globalconfig(item):
    configdict = {
                  'vm_transcription' : True, # Transcribe voicemail to text (requires Google cloud subscription)
                  'transcription_string' : '{{{{TRANSCRIPTION}}}}', # String to search for in the email which will be replaced by the transcribed text
                  'creds_file': '/path/to/creds.json', # Path to credentials json file, generated by Google
                  'speech_language' : 'en-US', # Language for speech recognition
                  'vm_to_mp3' : True, # Convert voicemail audio to MP3
                  'temp_dir': '/tmp', # Temp location for MP3 conversion. MUST BE WRITABLE!
                  'check_html' : True # Check to see if message is HTML and set mimetype accordingly
                 }
    return configdict[item]

def speechrec(wavobj):
    """
    Sends wav attachment to Google Speech Recognition Service.
    """
    stream = [base64.b64decode(wavobj)]
    client = speech.SpeechClient.from_service_account_json(globalconfig('creds_file'))
    requests = (
        speech.StreamingRecognizeRequest(audio_content=chunk) for chunk in stream
    )
    config = speech.RecognitionConfig(
        encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,
        sample_rate_hertz=8000,
        language_code=globalconfig('speech_language'),
    )
    streaming_config = speech.StreamingRecognitionConfig(config=config)
    responses = client.streaming_recognize(
        config=streaming_config,
        requests=requests,
    )
    transcription = []
    for response in responses:
        for result in response.results:
            if result.is_final:
                alternative = result.alternatives[0]
                transcription.append(alternative.transcript)
    return '. '.join(transcription)
    
def examinehtml(textobject, contenttype):
    """
    Checks to see if HTML tags exist in the message and changes content type
    """
    if not globalconfig('check_html'):
        return contenttype
    if (('<html>' in textobject) and ('</html>' in textobject)):
        return 'text/html'
    else:
        return 'text/plain'

def vmtomp3(filename, wavobj):
    """
    Converts wav attachments to MP3. Requires FFMPEG
    """
    outobj = base64.b64decode(wavobj)
    if not globalconfig('vm_to_mp3'):
        return [filename, 'audio/x-wav', outobj]
    randfilename = "{}{}".format(str(random.randint(1,10000000000)), filename)
    newrandfilename = "{}mp3".format(randfilename[:-3])
    tempfname = "{}/{}".format(globalconfig('temp_dir'), randfilename)
    tempnewfname = "{}/{}".format(globalconfig('temp_dir'), newrandfilename)
    try:
        tempwav = open(tempfname, "wb")
        tempwav.write(outobj)
        tempwav.close()
    except (Exception) as e:
        return [filename, 'audio/x-wav', outobj]
    ff = FFmpeg(
        inputs = {tempfname: None},
        outputs = {tempnewfname: ['-b:a', '16k']}
    )
    try:
        ff.run(stderr=PIPE)
    except Exception as e:
        return [filename, 'audio/x-wav', outobj]
    mp3handle = open(tempnewfname, 'rb')
    mp3dump = mp3handle.read()
    try:
        os.remove(tempfname)
        os.remove(tempnewfname)
    except:
        pass
    return ["{}mp3".format(filename[:-3]), 'audio/x-mpeg-3', mp3dump]
    
def main():
    # Get entire email from STDIN
    parser = email.message_from_file(sys.stdin)
    # If it's a multipart message we need to look for audio attachments
    if parser.is_multipart():
        for payload in parser.walk():
            if payload.get_content_type() == 'text/plain':
                textobj = payload.get_payload()
                newcontenttype = examinehtml(textobj, payload.get_content_type())
                for key, value in payload.items():
                    if key == 'Content-Type':
                        newheader = value.replace('text/plain', newcontenttype)
                        payload.replace_header(key, newheader)
            if payload.get_content_type() == 'audio/x-wav':
                waveobj = payload.get_payload()
                filename = payload.get_filename()
                # MP3 Conversion
                mp3conv = vmtomp3(filename, waveobj)
                # Transcription
                if globalconfig('vm_transcription'):
                    speech = ""
                    speech = speechrec(waveobj)
                # Iterate through headers and modify accordinglyl
                for key, value in payload.items():
                    if key == 'Content-Type':
                        newheader = value.replace('audio/x-wav', mp3conv[1])
                        newheader = newheader.replace(filename, mp3conv[0])
                        payload.replace_header(key,newheader)
                    if key == 'Content-Disposition':
                        newheader = value.replace(filename, mp3conv[0])
                        payload.replace_header(key,newheader)
                payload.set_payload(base64.b64encode(mp3conv[2]))
        if globalconfig('vm_transcription'):
            outstr = str(parser).replace(globalconfig('transcription_string'), speech)
        else:
            outstr = str(parser).replace(globalconfig('transcription_string'), "No transcription.")
        # First line has garbage we don't need...
        indx1 = outstr.find('\n')
        # Output finished email to stdout
        sys.stdout.write(outstr[indx1+1:])
    else:
        outstr = str(parser)
        if parser.get_content_type() == 'text/plain':
            textobj = parser.get_payload()
            newcontenttype = examinehtml(textobj, parser.get_content_type())
            for key,value in parser.items():
                if key == 'Content-Type':
                    newheader = value.replace('text/plain', newcontenttype)
                    parser.replace_header(key,newheader)
        outstr = outstr.replace('text/plain', newcontenttype)
        outstr = outstr.replace(globalconfig('transcription_string'), "No transcription.")
        # First line has garbage we don't need...
        indx1 = outstr.find('\n')
        # Output finished email to stdout
        sys.stdout.write(outstr[indx1+1:])

sys.exit(main())
